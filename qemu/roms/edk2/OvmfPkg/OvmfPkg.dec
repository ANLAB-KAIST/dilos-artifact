## @file
#  EFI/Framework Open Virtual Machine Firmware (OVMF) platform
#
#  Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
#
#  SPDX-License-Identifier: BSD-2-Clause-Patent
#
##

[Defines]
  DEC_SPECIFICATION              = 0x00010005
  PACKAGE_NAME                   = OvmfPkg
  PACKAGE_GUID                   = 2daf5f34-50e5-4b9d-b8e3-5562334d87e5
  PACKAGE_VERSION                = 0.1

[Includes]
  Include

[LibraryClasses]
  ##  @libraryclass  Loads and boots a Linux kernel image
  #
  LoadLinuxLib|Include/Library/LoadLinuxLib.h

  ##  @libraryclass  Save and restore variables using a file
  #
  NvVarsFileLib|Include/Library/NvVarsFileLib.h

  ##  @libraryclass  Provides services to work with PCI capabilities in PCI
  #                  config space.
  PciCapLib|Include/Library/PciCapLib.h

  ##  @libraryclass  Layered on top of PciCapLib, allows clients to plug an
  #                  EFI_PCI_IO_PROTOCOL backend into PciCapLib, for config
  #                  space access.
  PciCapPciIoLib|Include/Library/PciCapPciIoLib.h

  ##  @libraryclass  Layered on top of PciCapLib, allows clients to plug a
  #                  PciSegmentLib backend into PciCapLib, for config space
  #                  access.
  PciCapPciSegmentLib|Include/Library/PciCapPciSegmentLib.h

  ##  @libraryclass  Register a status code handler for printing the Boot
  #                  Manager's LoadImage() and StartImage() preparations, and
  #                  return codes, to the UEFI console.
  PlatformBmPrintScLib|Include/Library/PlatformBmPrintScLib.h

  ##  @libraryclass  Access QEMU's firmware configuration interface
  #
  QemuFwCfgLib|Include/Library/QemuFwCfgLib.h

  ##  @libraryclass  S3 support for QEMU fw_cfg
  #
  QemuFwCfgS3Lib|Include/Library/QemuFwCfgS3Lib.h

  ##  @libraryclass  Rewrite the BootOrder NvVar based on QEMU's "bootorder"
  #                  fw_cfg file.
  #
  QemuBootOrderLib|Include/Library/QemuBootOrderLib.h

  ##  @libraryclass  Serialize (and deserialize) variables
  #
  SerializeVariablesLib|Include/Library/SerializeVariablesLib.h

  ##  @libraryclass  Invoke Xen hypercalls
  #
  XenHypercallLib|Include/Library/XenHypercallLib.h

  ##  @libraryclass  Manage XenBus device path and I/O handles
  #
  XenIoMmioLib|Include/Library/XenIoMmioLib.h

[Guids]
  gUefiOvmfPkgTokenSpaceGuid          = {0x93bb96af, 0xb9f2, 0x4eb8, {0x94, 0x62, 0xe0, 0xba, 0x74, 0x56, 0x42, 0x36}}
  gEfiXenInfoGuid                     = {0xd3b46f3b, 0xd441, 0x1244, {0x9a, 0x12, 0x0, 0x12, 0x27, 0x3f, 0xc1, 0x4d}}
  gOvmfPkKek1AppPrefixGuid            = {0x4e32566d, 0x8e9e, 0x4f52, {0x81, 0xd3, 0x5b, 0xb9, 0x71, 0x5f, 0x97, 0x27}}
  gOvmfPlatformConfigGuid             = {0x7235c51c, 0x0c80, 0x4cab, {0x87, 0xac, 0x3b, 0x08, 0x4a, 0x63, 0x04, 0xb1}}
  gVirtioMmioTransportGuid            = {0x837dca9e, 0xe874, 0x4d82, {0xb2, 0x9a, 0x23, 0xfe, 0x0e, 0x23, 0xd1, 0xe2}}
  gQemuRamfbGuid                      = {0x557423a1, 0x63ab, 0x406c, {0xbe, 0x7e, 0x91, 0xcd, 0xbc, 0x08, 0xc4, 0x57}}
  gXenBusRootDeviceGuid               = {0xa732241f, 0x383d, 0x4d9c, {0x8a, 0xe1, 0x8e, 0x09, 0x83, 0x75, 0x89, 0xd7}}
  gRootBridgesConnectedEventGroupGuid = {0x24a2d66f, 0xeedd, 0x4086, {0x90, 0x42, 0xf2, 0x6e, 0x47, 0x97, 0xee, 0x69}}
  gMicrosoftVendorGuid                = {0x77fa9abd, 0x0359, 0x4d32, {0xbd, 0x60, 0x28, 0xf4, 0xe7, 0x8f, 0x78, 0x4b}}

[Protocols]
  gVirtioDeviceProtocolGuid           = {0xfa920010, 0x6785, 0x4941, {0xb6, 0xec, 0x49, 0x8c, 0x57, 0x9f, 0x16, 0x0a}}
  gXenBusProtocolGuid                 = {0x3d3ca290, 0xb9a5, 0x11e3, {0xb7, 0x5d, 0xb8, 0xac, 0x6f, 0x7d, 0x65, 0xe6}}
  gXenIoProtocolGuid                  = {0x6efac84f, 0x0ab0, 0x4747, {0x81, 0xbe, 0x85, 0x55, 0x62, 0x59, 0x04, 0x49}}
  gIoMmuAbsentProtocolGuid            = {0xf8775d50, 0x8abd, 0x4adf, {0x92, 0xac, 0x85, 0x3e, 0x51, 0xf6, 0xc8, 0xdc}}
  gEfiLegacy8259ProtocolGuid          = {0x38321dba, 0x4fe0, 0x4e17, {0x8a, 0xec, 0x41, 0x30, 0x55, 0xea, 0xed, 0xc1}}

[PcdsFixedAtBuild]
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfPeiMemFvBase|0x0|UINT32|0
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfPeiMemFvSize|0x0|UINT32|1
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfDxeMemFvBase|0x0|UINT32|0x15
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfDxeMemFvSize|0x0|UINT32|0x16

  ## This flag is used to control the destination port for PlatformDebugLibIoPort
  gUefiOvmfPkgTokenSpaceGuid.PcdDebugIoPort|0x402|UINT16|4

  ## When VirtioScsiDxe is instantiated for a HBA, the numbers of targets and
  #  LUNs are retrieved from the host during virtio-scsi setup.
  #  MdeModulePkg/Bus/Scsi/ScsiBusDxe then scans all MaxTarget * MaxLun
  #  possible devices. This can take extremely long, for example with
  #  MaxTarget=255 and MaxLun=16383. The *inclusive* constants below limit
  #  MaxTarget and MaxLun, independently, should the host report higher values,
  #  so that scanning the number of devices given by their product is still
  #  acceptably fast.
  gUefiOvmfPkgTokenSpaceGuid.PcdVirtioScsiMaxTargetLimit|31|UINT16|6
  gUefiOvmfPkgTokenSpaceGuid.PcdVirtioScsiMaxLunLimit|7|UINT32|7

  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageEventLogBase|0x0|UINT32|0x8
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageEventLogSize|0x0|UINT32|0x9
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFirmwareFdSize|0x0|UINT32|0xa
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFirmwareBlockSize|0|UINT32|0xb
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageVariableBase|0x0|UINT32|0xc
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageFtwSpareBase|0x0|UINT32|0xd
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashNvStorageFtwWorkingBase|0x0|UINT32|0xe
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFdBaseAddress|0x0|UINT32|0xf
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPageTablesBase|0x0|UINT32|0x11
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPageTablesSize|0x0|UINT32|0x12
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPeiTempRamBase|0x0|UINT32|0x13
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfSecPeiTempRamSize|0x0|UINT32|0x14
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfLockBoxStorageBase|0x0|UINT32|0x18
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfLockBoxStorageSize|0x0|UINT32|0x19
  gUefiOvmfPkgTokenSpaceGuid.PcdGuidedExtractHandlerTableSize|0x0|UINT32|0x1a
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfDecompressionScratchEnd|0x0|UINT32|0x1f

  ## Pcd8259LegacyModeMask defines the default mask value for platform. This
  #  value is determined.
  #  1) If platform only support pure UEFI, value should be set to 0xFFFF or
  #     0xFFFE; Because only clock interrupt is allowed in legacy mode in pure
  #     UEFI platform.
  #  2) If platform install CSM and use thunk module:
  #     a) If thunk call provided by CSM binary requires some legacy interrupt
  #        support, the corresponding bit should be opened as 0.
  #        For example, if keyboard interfaces provided CSM binary use legacy
  #        keyboard interrupt in 8259 bit 1, then the value should be set to
  #        0xFFFC.
  #     b) If all thunk call provied by CSM binary do not require legacy
  #        interrupt support, value should be set to 0xFFFF or 0xFFFE.
  #
  #  The default value of legacy mode mask could be changed by
  #  EFI_LEGACY_8259_PROTOCOL->SetMask(). But it is rarely need change it
  #  except some special cases such as when initializing the CSM binary, it
  #  should be set to 0xFFFF to mask all legacy interrupt. Please restore the
  #  original legacy mask value if changing is made for these special case.
  gUefiOvmfPkgTokenSpaceGuid.Pcd8259LegacyModeMask|0xFFFF|UINT16|0x3

  ## Pcd8259LegacyModeEdgeLevel defines the default edge level for legacy
  #  mode's interrrupt controller.
  #  For the corresponding bits, 0 = Edge triggered and 1 = Level triggered.
  gUefiOvmfPkgTokenSpaceGuid.Pcd8259LegacyModeEdgeLevel|0x0000|UINT16|0x5

[PcdsDynamic, PcdsDynamicEx]
  gUefiOvmfPkgTokenSpaceGuid.PcdEmuVariableEvent|0|UINT64|2
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashVariablesEnable|FALSE|BOOLEAN|0x10
  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfHostBridgePciDevId|0|UINT16|0x1b
  gUefiOvmfPkgTokenSpaceGuid.PcdQemuSmbiosValidated|FALSE|BOOLEAN|0x21

  ## The IO port aperture shared by all PCI root bridges.
  #
  gUefiOvmfPkgTokenSpaceGuid.PcdPciIoBase|0x0|UINT64|0x22
  gUefiOvmfPkgTokenSpaceGuid.PcdPciIoSize|0x0|UINT64|0x23

  ## The 32-bit MMIO aperture shared by all PCI root bridges.
  #
  gUefiOvmfPkgTokenSpaceGuid.PcdPciMmio32Base|0x0|UINT64|0x24
  gUefiOvmfPkgTokenSpaceGuid.PcdPciMmio32Size|0x0|UINT64|0x25

  ## The 64-bit MMIO aperture shared by all PCI root bridges.
  #
  gUefiOvmfPkgTokenSpaceGuid.PcdPciMmio64Base|0x0|UINT64|0x26
  gUefiOvmfPkgTokenSpaceGuid.PcdPciMmio64Size|0x0|UINT64|0x27

  ## The following setting controls how many megabytes we configure as TSEG on
  #  Q35, for SMRAM purposes. Permitted defaults are: 1, 2, 8. Other defaults
  #  cause undefined behavior. During boot, the PCD is updated by PlatformPei
  #  to reflect the extended TSEG size, if one is advertized by QEMU.
  #
  #  This PCD is only accessed if PcdSmmSmramRequire is TRUE (see below).
  gUefiOvmfPkgTokenSpaceGuid.PcdQ35TsegMbytes|8|UINT16|0x20

[PcdsFeatureFlag]
  gUefiOvmfPkgTokenSpaceGuid.PcdQemuBootOrderPciTranslation|TRUE|BOOLEAN|0x1c
  gUefiOvmfPkgTokenSpaceGuid.PcdQemuBootOrderMmioTranslation|FALSE|BOOLEAN|0x1d

  ## This feature flag enables SMM/SMRAM support. Note that it also requires
  #  such support from the underlying QEMU instance; if that support is not
  #  present, the firmware will reject continuing after a certain point.
  #
  #  The flag also acts as a general "security switch"; when TRUE, many
  #  components will change behavior, with the goal of preventing a malicious
  #  runtime OS from tampering with firmware structures (special memory ranges
  #  used by OVMF, the varstore pflash chip, LockBox etc).
  gUefiOvmfPkgTokenSpaceGuid.PcdSmmSmramRequire|FALSE|BOOLEAN|0x1e
